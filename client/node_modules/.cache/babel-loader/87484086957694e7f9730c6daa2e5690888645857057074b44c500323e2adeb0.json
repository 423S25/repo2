{"ast":null,"code":"'use client';\n\nimport { useState, useRef, useMemo, useCallback } from 'react';\nimport { getInputOnChange } from './get-input-on-change/get-input-on-change.mjs';\nimport 'klona/full';\nimport { shouldValidateOnChange } from './validate/should-validate-on-change.mjs';\nfunction useField({\n  mode = \"controlled\",\n  clearErrorOnChange = true,\n  initialValue,\n  initialError = null,\n  initialTouched = false,\n  onValueChange,\n  validateOnChange = false,\n  validateOnBlur = false,\n  validate,\n  resolveValidationError,\n  type = \"input\"\n}) {\n  const [valueState, setValueState] = useState(initialValue);\n  const valueRef = useRef(valueState);\n  const [key, setKey] = useState(0);\n  const [error, setError] = useState(initialError || null);\n  const touchedRef = useRef(initialTouched || false);\n  const [, setTouchedState] = useState(touchedRef.current);\n  const [isValidating, setIsValidating] = useState(false);\n  const errorResolver = useMemo(() => resolveValidationError || (err => err), [resolveValidationError]);\n  const setTouched = useCallback((val, {\n    updateState = mode === \"controlled\"\n  } = {}) => {\n    touchedRef.current = val;\n    updateState && setTouchedState(val);\n  }, []);\n  const setValue = useCallback((value, {\n    updateKey = mode === \"uncontrolled\",\n    updateState = mode === \"controlled\"\n  } = {}) => {\n    if (valueRef.current === value) {\n      return;\n    }\n    valueRef.current = value;\n    onValueChange?.(value);\n    if (clearErrorOnChange && error !== null) {\n      setError(null);\n    }\n    if (updateState) {\n      setValueState(value);\n    }\n    if (updateKey) {\n      setKey(currentKey => currentKey + 1);\n    }\n    if (validateOnChange) {\n      _validate();\n    }\n  }, [error, clearErrorOnChange]);\n  const reset = useCallback(() => {\n    setValue(initialValue);\n    setError(null);\n    setTouched(false);\n  }, [initialValue]);\n  const getValue = useCallback(() => valueRef.current, []);\n  const isTouched = useCallback(() => touchedRef.current, []);\n  const isDirty = useCallback(() => valueRef.current !== initialValue, [initialValue]);\n  const _validate = useCallback(async () => {\n    const validationResult = validate?.(valueRef.current);\n    if (validationResult instanceof Promise) {\n      setIsValidating(true);\n      try {\n        const result = await validationResult;\n        setIsValidating(false);\n        setError(result);\n      } catch (err) {\n        setIsValidating(false);\n        const resolvedError = errorResolver(err);\n        setError(resolvedError);\n        return resolvedError;\n      }\n    } else {\n      setError(validationResult);\n      return validationResult;\n    }\n  }, []);\n  const getInputProps = ({\n    withError = true,\n    withFocus = true\n  } = {}) => {\n    const onChange = getInputOnChange(val => setValue(val, {\n      updateKey: false\n    }));\n    const payload = {\n      onChange\n    };\n    if (withError) {\n      payload.error = error;\n    }\n    if (type === \"checkbox\") {\n      payload[mode === \"controlled\" ? \"checked\" : \"defaultChecked\"] = valueRef.current;\n    } else {\n      payload[mode === \"controlled\" ? \"value\" : \"defaultValue\"] = valueRef.current;\n    }\n    if (withFocus) {\n      payload.onFocus = () => {\n        setTouched(true);\n      };\n      payload.onBlur = () => {\n        if (shouldValidateOnChange(\"\", !!validateOnBlur)) {\n          _validate();\n        }\n      };\n    }\n    return payload;\n  };\n  const resetTouched = useCallback(() => setTouched(false), []);\n  return {\n    key,\n    getValue,\n    setValue,\n    reset,\n    getInputProps,\n    isValidating,\n    validate: _validate,\n    error,\n    setError,\n    isTouched,\n    isDirty,\n    resetTouched\n  };\n}\nexport { useField };","map":{"version":3,"names":["useField","mode","clearErrorOnChange","initialValue","initialError","initialTouched","onValueChange","validateOnChange","validateOnBlur","validate","resolveValidationError","type","valueState","setValueState","useState","valueRef","useRef","key","setKey","error","setError","touchedRef","setTouchedState","current","isValidating","setIsValidating","errorResolver","useMemo","err","setTouched","useCallback","val","updateState","setValue","value","updateKey","currentKey","_validate","reset","getValue","isTouched","isDirty","validationResult","Promise","result","resolvedError","getInputProps","withError","withFocus","onChange","getInputOnChange","payload","onFocus","onBlur","shouldValidateOnChange","resetTouched"],"sources":["/Users/jackson/loginsystem/client/node_modules/@mantine/form/src/use-field.ts"],"sourcesContent":["import { useCallback, useMemo, useRef, useState } from 'react';\nimport { getInputOnChange } from './get-input-on-change';\nimport { FormMode, GetInputPropsType } from './types';\nimport { shouldValidateOnChange } from './validate';\n\ntype UseFieldErrorResolver = (error: unknown) => React.ReactNode;\n\nexport interface UseFieldInput<\n  T,\n  FieldType extends GetInputPropsType = 'input',\n  Mode extends FormMode = 'controlled',\n> {\n  /** Field mode, controlled by default */\n  mode?: Mode;\n\n  /** Initial field value */\n  initialValue: T;\n\n  /** Initial touched value */\n  initialTouched?: boolean;\n\n  /** Initial field error message */\n  initialError?: React.ReactNode;\n\n  /** Called with updated value when the field value changes */\n  onValueChange?: (value: T) => void;\n\n  /** Determines whether the field should be validated when value changes, false by default */\n  validateOnChange?: boolean;\n\n  /** Determines whether the field should be validated when it loses focus, false by default */\n  validateOnBlur?: boolean;\n\n  /** Determines whether the field should clear error message when value changes, true by default */\n  clearErrorOnChange?: boolean;\n\n  /** A function to validate field value, can be sync or async */\n  validate?: (value: T) => React.ReactNode | Promise<React.ReactNode>;\n\n  /** Field type, input by default */\n  type?: FieldType;\n\n  /** A function to resolve validation error from the result returned from validate function, should return react node */\n  resolveValidationError?: UseFieldErrorResolver;\n}\n\ninterface SetValueOptions {\n  updateState?: boolean;\n  updateKey?: boolean;\n}\n\ninterface GetInputPropsOptions {\n  withError?: boolean;\n  withFocus?: boolean;\n}\n\ninterface GetInputPropsSharedReturn {\n  error?: React.ReactNode;\n  onFocus?: () => void;\n  onBlur: () => void;\n  onChange: (value: any) => void;\n}\n\ntype GetInputPropsTypeValue<\n  T,\n  FieldType extends GetInputPropsType,\n  Mode extends FormMode,\n> = FieldType extends 'checkbox'\n  ? Mode extends 'controlled'\n    ? { checked: boolean }\n    : { defaultChecked: boolean }\n  : Mode extends 'controlled'\n    ? { value: T }\n    : { defaultValue: T };\n\ntype GetInputPropsReturnType<\n  T,\n  FieldType extends GetInputPropsType,\n  Mode extends FormMode,\n> = GetInputPropsSharedReturn & GetInputPropsTypeValue<T, FieldType, Mode>;\n\nexport interface UseFieldReturnType<\n  T,\n  FieldType extends GetInputPropsType = 'input',\n  Mode extends FormMode = 'controlled',\n> {\n  /** Returns props to pass to the input element */\n  getInputProps: (options?: GetInputPropsOptions) => GetInputPropsReturnType<T, FieldType, Mode>;\n\n  /** Returns current input value */\n  getValue: () => T;\n\n  /** Sets input value to the given value */\n  setValue: (value: T) => void;\n\n  /** Resets field value to initial state, sets touched state to false, sets error to null */\n  reset: () => void;\n\n  /** Validates current input value when called */\n  validate: () => Promise<React.ReactNode | void>;\n\n  /** Set to true when async validate function is called, stays true until the returned promise resolves */\n  isValidating: boolean;\n\n  /** Current error message */\n  error: React.ReactNode;\n\n  /** Sets error message to the given react node */\n  setError: (error: React.ReactNode) => void;\n\n  /** Returns true if the input has been focused at least once */\n  isTouched: () => boolean;\n\n  /** Returns true if input value is different from the initial value */\n  isDirty: () => boolean;\n\n  /** Resets touched state to false */\n  resetTouched: () => void;\n\n  /** Key that should be added to the input when mode is uncontrolled */\n  key: number;\n}\n\nexport function useField<\n  T,\n  Mode extends FormMode = 'controlled',\n  FieldType extends GetInputPropsType = 'input',\n>({\n  mode = 'controlled' as Mode,\n  clearErrorOnChange = true,\n  initialValue,\n  initialError = null,\n  initialTouched = false,\n  onValueChange,\n  validateOnChange = false,\n  validateOnBlur = false,\n  validate,\n  resolveValidationError,\n  type = 'input' as FieldType,\n}: UseFieldInput<T, FieldType, Mode>): UseFieldReturnType<T, FieldType, Mode> {\n  const [valueState, setValueState] = useState(initialValue);\n  const valueRef = useRef(valueState);\n  const [key, setKey] = useState(0);\n  const [error, setError] = useState<React.ReactNode>(initialError || null);\n  const touchedRef = useRef(initialTouched || false);\n  const [, setTouchedState] = useState(touchedRef.current);\n  const [isValidating, setIsValidating] = useState(false);\n  const errorResolver: UseFieldErrorResolver = useMemo(\n    () => resolveValidationError || ((err) => err as React.ReactNode),\n    [resolveValidationError]\n  );\n\n  const setTouched = useCallback((val: boolean, { updateState = mode === 'controlled' } = {}) => {\n    touchedRef.current = val;\n    updateState && setTouchedState(val);\n  }, []);\n\n  const setValue = useCallback(\n    (\n      value: T,\n      {\n        updateKey = mode === 'uncontrolled',\n        updateState = mode === 'controlled',\n      }: SetValueOptions = {}\n    ) => {\n      if (valueRef.current === value) {\n        return;\n      }\n\n      valueRef.current = value;\n\n      onValueChange?.(value);\n\n      if (clearErrorOnChange && error !== null) {\n        setError(null);\n      }\n\n      if (updateState) {\n        setValueState(value);\n      }\n\n      if (updateKey) {\n        setKey((currentKey) => currentKey + 1);\n      }\n\n      if (validateOnChange) {\n        _validate();\n      }\n    },\n    [error, clearErrorOnChange]\n  );\n\n  const reset = useCallback(() => {\n    setValue(initialValue);\n    setError(null);\n    setTouched(false);\n  }, [initialValue]);\n\n  const getValue = useCallback(() => valueRef.current, []);\n\n  const isTouched = useCallback(() => touchedRef.current, []);\n\n  const isDirty = useCallback(() => valueRef.current !== initialValue, [initialValue]);\n\n  const _validate = useCallback(async () => {\n    const validationResult = validate?.(valueRef.current);\n\n    if (validationResult instanceof Promise) {\n      setIsValidating(true);\n      try {\n        const result = await validationResult;\n        setIsValidating(false);\n        setError(result);\n      } catch (err) {\n        setIsValidating(false);\n        const resolvedError = errorResolver(err);\n        setError(resolvedError);\n        return resolvedError;\n      }\n    } else {\n      setError(validationResult);\n      return validationResult;\n    }\n  }, []);\n\n  const getInputProps = ({ withError = true, withFocus = true } = {}) => {\n    const onChange = getInputOnChange<T>((val) => setValue(val as any, { updateKey: false }));\n\n    const payload: any = { onChange };\n\n    if (withError) {\n      payload.error = error;\n    }\n\n    if (type === 'checkbox') {\n      payload[mode === 'controlled' ? 'checked' : 'defaultChecked'] = valueRef.current;\n    } else {\n      payload[mode === 'controlled' ? 'value' : 'defaultValue'] = valueRef.current;\n    }\n\n    if (withFocus) {\n      payload.onFocus = () => {\n        setTouched(true);\n      };\n\n      payload.onBlur = () => {\n        if (shouldValidateOnChange('', !!validateOnBlur)) {\n          _validate();\n        }\n      };\n    }\n\n    return payload;\n  };\n\n  const resetTouched = useCallback(() => setTouched(false), []);\n\n  return {\n    key,\n    getValue,\n    setValue,\n    reset,\n    getInputProps,\n\n    isValidating,\n    validate: _validate,\n\n    error,\n    setError,\n\n    isTouched,\n    isDirty,\n    resetTouched,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}