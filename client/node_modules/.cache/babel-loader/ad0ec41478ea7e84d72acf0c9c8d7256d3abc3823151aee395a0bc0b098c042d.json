{"ast":null,"code":"'use client';\n\nimport { useState, useRef, useCallback } from 'react';\nimport isEqual from 'fast-deep-equal';\nimport { getStatus } from '../../get-status/get-status.mjs';\nimport { clearListState } from '../../lists/clear-list-state.mjs';\nimport { getPath } from '../../paths/get-path.mjs';\nimport 'klona/full';\nfunction useFormStatus({\n  initialDirty,\n  initialTouched,\n  mode,\n  $values\n}) {\n  const [touchedState, setTouchedState] = useState(initialTouched);\n  const [dirtyState, setDirtyState] = useState(initialDirty);\n  const touchedRef = useRef(initialTouched);\n  const dirtyRef = useRef(initialDirty);\n  const setTouched = useCallback(values => {\n    const resolvedValues = typeof values === \"function\" ? values(touchedRef.current) : values;\n    touchedRef.current = resolvedValues;\n    if (mode === \"controlled\") {\n      setTouchedState(resolvedValues);\n    }\n  }, []);\n  const setDirty = useCallback((values, forceUpdate = false) => {\n    const resolvedValues = typeof values === \"function\" ? values(dirtyRef.current) : values;\n    dirtyRef.current = resolvedValues;\n    if (mode === \"controlled\" || forceUpdate) {\n      setDirtyState(resolvedValues);\n    }\n  }, []);\n  const resetTouched = useCallback(() => setTouched({}), []);\n  const resetDirty = useCallback(values => {\n    const newSnapshot = values ? {\n      ...$values.refValues.current,\n      ...values\n    } : $values.refValues.current;\n    $values.setValuesSnapshot(newSnapshot);\n    setDirty({});\n  }, []);\n  const setFieldTouched = useCallback((path, touched) => {\n    setTouched(currentTouched => {\n      if (getStatus(currentTouched, path) === touched) {\n        return currentTouched;\n      }\n      return {\n        ...currentTouched,\n        [path]: touched\n      };\n    });\n  }, []);\n  const setFieldDirty = useCallback((path, dirty, forceUpdate) => {\n    setDirty(currentDirty => {\n      if (getStatus(currentDirty, path) === dirty) {\n        return currentDirty;\n      }\n      return {\n        ...currentDirty,\n        [path]: dirty\n      };\n    }, forceUpdate);\n  }, []);\n  const setCalculatedFieldDirty = useCallback((path, value) => {\n    const currentDirty = getStatus(dirtyRef.current, path);\n    const dirty = !isEqual(getPath(path, $values.getValuesSnapshot()), value);\n    const clearedState = clearListState(path, dirtyRef.current);\n    clearedState[path] = dirty;\n    setDirty(clearedState, currentDirty !== dirty);\n  }, []);\n  const isTouched = useCallback(path => getStatus(touchedRef.current, path), []);\n  const clearFieldDirty = useCallback(path => setDirty(current => {\n    if (typeof path !== \"string\") {\n      return current;\n    }\n    const result = clearListState(path, current);\n    delete result[path];\n    if (isEqual(result, current)) {\n      return current;\n    }\n    return result;\n  }), []);\n  const isDirty = useCallback(path => {\n    if (path) {\n      const overriddenValue = getPath(path, dirtyRef.current);\n      if (typeof overriddenValue === \"boolean\") {\n        return overriddenValue;\n      }\n      const sliceOfValues = getPath(path, $values.refValues.current);\n      const sliceOfInitialValues = getPath(path, $values.valuesSnapshot.current);\n      return !isEqual(sliceOfValues, sliceOfInitialValues);\n    }\n    const isOverridden = Object.keys(dirtyRef.current).length > 0;\n    if (isOverridden) {\n      return getStatus(dirtyRef.current);\n    }\n    return !isEqual($values.refValues.current, $values.valuesSnapshot.current);\n  }, []);\n  const getDirty = useCallback(() => dirtyRef.current, []);\n  const getTouched = useCallback(() => touchedRef.current, []);\n  return {\n    touchedState,\n    dirtyState,\n    touchedRef,\n    dirtyRef,\n    setTouched,\n    setDirty,\n    resetDirty,\n    resetTouched,\n    isTouched,\n    setFieldTouched,\n    setFieldDirty,\n    setTouchedState,\n    setDirtyState,\n    clearFieldDirty,\n    isDirty,\n    getDirty,\n    getTouched,\n    setCalculatedFieldDirty\n  };\n}\nexport { useFormStatus };","map":{"version":3,"names":["useFormStatus","initialDirty","initialTouched","mode","$values","touchedState","setTouchedState","useState","dirtyState","setDirtyState","touchedRef","useRef","dirtyRef","setTouched","useCallback","values","resolvedValues","current","setDirty","forceUpdate","resetTouched","resetDirty","newSnapshot","refValues","setValuesSnapshot","setFieldTouched","path","touched","currentTouched","getStatus","setFieldDirty","dirty","currentDirty","setCalculatedFieldDirty","value","isEqual","getPath","getValuesSnapshot","clearedState","clearListState","isTouched","clearFieldDirty","result","isDirty","overriddenValue","sliceOfValues","sliceOfInitialValues","valuesSnapshot","isOverridden","Object","keys","length","getDirty","getTouched"],"sources":["/Users/jackson/loginsystem/client/node_modules/@mantine/form/src/hooks/use-form-status/use-form-status.ts"],"sourcesContent":["import { useCallback, useRef, useState } from 'react';\nimport isEqual from 'fast-deep-equal';\nimport { getStatus } from '../../get-status';\nimport { clearListState } from '../../lists';\nimport { getPath } from '../../paths';\nimport {\n  ClearFieldDirty,\n  FormMode,\n  FormStatus,\n  GetFieldStatus,\n  ResetDirty,\n  ResetStatus,\n  SetCalculatedFieldDirty,\n  SetFieldDirty,\n  SetFieldTouched,\n} from '../../types';\nimport type { $FormValues } from '../use-form-values/use-form-values';\n\nexport interface $FormStatus<Values extends Record<string, any>> {\n  touchedState: FormStatus;\n  dirtyState: FormStatus;\n  touchedRef: React.MutableRefObject<FormStatus>;\n  dirtyRef: React.MutableRefObject<FormStatus>;\n  setTouched: React.Dispatch<React.SetStateAction<FormStatus>>;\n  setDirty: React.Dispatch<React.SetStateAction<FormStatus>>;\n  resetDirty: ResetStatus;\n  resetTouched: ResetStatus;\n  isTouched: GetFieldStatus<Values>;\n  setFieldTouched: SetFieldTouched<Values>;\n  setFieldDirty: SetFieldDirty<Values>;\n  setTouchedState: React.Dispatch<React.SetStateAction<FormStatus>>;\n  setDirtyState: React.Dispatch<React.SetStateAction<FormStatus>>;\n  clearFieldDirty: ClearFieldDirty;\n  isDirty: GetFieldStatus<Values>;\n  getDirty: () => FormStatus;\n  getTouched: () => FormStatus;\n  setCalculatedFieldDirty: SetCalculatedFieldDirty<Values>;\n}\n\ninterface UseFormStatusInput<Values extends Record<string, any>> {\n  initialDirty: FormStatus;\n  initialTouched: FormStatus;\n  mode: FormMode;\n  $values: $FormValues<Values>;\n}\n\nexport function useFormStatus<Values extends Record<string, any>>({\n  initialDirty,\n  initialTouched,\n  mode,\n  $values,\n}: UseFormStatusInput<Values>): $FormStatus<Values> {\n  const [touchedState, setTouchedState] = useState(initialTouched);\n  const [dirtyState, setDirtyState] = useState(initialDirty);\n\n  const touchedRef = useRef(initialTouched);\n  const dirtyRef = useRef(initialDirty);\n\n  const setTouched = useCallback((values: FormStatus | ((current: FormStatus) => FormStatus)) => {\n    const resolvedValues = typeof values === 'function' ? values(touchedRef.current) : values;\n    touchedRef.current = resolvedValues;\n\n    if (mode === 'controlled') {\n      setTouchedState(resolvedValues);\n    }\n  }, []);\n\n  const setDirty = useCallback(\n    (values: FormStatus | ((current: FormStatus) => FormStatus), forceUpdate = false) => {\n      const resolvedValues = typeof values === 'function' ? values(dirtyRef.current) : values;\n      dirtyRef.current = resolvedValues;\n\n      if (mode === 'controlled' || forceUpdate) {\n        setDirtyState(resolvedValues);\n      }\n    },\n    []\n  );\n\n  const resetTouched: ResetStatus = useCallback(() => setTouched({}), []);\n\n  const resetDirty: ResetDirty<Values> = useCallback((values) => {\n    const newSnapshot = values\n      ? { ...$values.refValues.current, ...values }\n      : $values.refValues.current;\n    $values.setValuesSnapshot(newSnapshot);\n    setDirty({});\n  }, []);\n\n  const setFieldTouched: SetFieldTouched<Values> = useCallback((path, touched) => {\n    setTouched((currentTouched) => {\n      if (getStatus(currentTouched, path) === touched) {\n        return currentTouched;\n      }\n\n      return { ...currentTouched, [path]: touched };\n    });\n  }, []);\n\n  const setFieldDirty: SetFieldDirty<Values> = useCallback((path, dirty, forceUpdate) => {\n    setDirty((currentDirty) => {\n      if (getStatus(currentDirty, path) === dirty) {\n        return currentDirty;\n      }\n\n      return { ...currentDirty, [path]: dirty };\n    }, forceUpdate);\n  }, []);\n\n  const setCalculatedFieldDirty: SetCalculatedFieldDirty<Values> = useCallback((path, value) => {\n    const currentDirty = getStatus(dirtyRef.current, path);\n    const dirty = !isEqual(getPath(path, $values.getValuesSnapshot()), value);\n    const clearedState = clearListState(path, dirtyRef.current);\n    clearedState[path as string] = dirty;\n    setDirty(clearedState, currentDirty !== dirty);\n  }, []);\n\n  const isTouched: GetFieldStatus<Values> = useCallback(\n    (path) => getStatus(touchedRef.current, path),\n    []\n  );\n\n  const clearFieldDirty: ClearFieldDirty = useCallback(\n    (path) =>\n      setDirty((current) => {\n        if (typeof path !== 'string') {\n          return current;\n        }\n\n        const result = clearListState(path, current);\n        delete result[path];\n\n        if (isEqual(result, current)) {\n          return current;\n        }\n\n        return result;\n      }),\n    []\n  );\n\n  const isDirty: GetFieldStatus<Values> = useCallback((path) => {\n    if (path) {\n      const overriddenValue = getPath(path, dirtyRef.current);\n      if (typeof overriddenValue === 'boolean') {\n        return overriddenValue;\n      }\n\n      const sliceOfValues = getPath(path, $values.refValues.current);\n      const sliceOfInitialValues = getPath(path, $values.valuesSnapshot.current);\n      return !isEqual(sliceOfValues, sliceOfInitialValues);\n    }\n\n    const isOverridden = Object.keys(dirtyRef.current).length > 0;\n    if (isOverridden) {\n      return getStatus(dirtyRef.current);\n    }\n\n    return !isEqual($values.refValues.current, $values.valuesSnapshot.current);\n  }, []);\n\n  const getDirty = useCallback(() => dirtyRef.current, []);\n  const getTouched = useCallback(() => touchedRef.current, []);\n\n  return {\n    touchedState,\n    dirtyState,\n    touchedRef,\n    dirtyRef,\n    setTouched,\n    setDirty,\n    resetDirty,\n    resetTouched,\n    isTouched,\n    setFieldTouched,\n    setFieldDirty,\n    setTouchedState,\n    setDirtyState,\n    clearFieldDirty,\n    isDirty,\n    getDirty,\n    getTouched,\n    setCalculatedFieldDirty,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}