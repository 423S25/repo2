{"ast":null,"code":"'use client';\n\nimport { clearListState } from './clear-list-state.mjs';\nfunction getIndexFromKeyAfterPath(key, path) {\n  const split = key.substring(path.length + 1).split(\".\")[0];\n  return parseInt(split, 10);\n}\nfunction changeErrorIndices(path, index, errors, change) {\n  if (index === void 0) {\n    return errors;\n  }\n  const pathString = `${String(path)}`;\n  let clearedErrors = errors;\n  if (change === -1) {\n    clearedErrors = clearListState(`${pathString}.${index}`, clearedErrors);\n  }\n  const cloned = {\n    ...clearedErrors\n  };\n  const changedKeys = /* @__PURE__ */new Set();\n  Object.entries(clearedErrors).filter(([key]) => {\n    if (!key.startsWith(`${pathString}.`)) {\n      return false;\n    }\n    const currIndex = getIndexFromKeyAfterPath(key, pathString);\n    if (Number.isNaN(currIndex)) {\n      return false;\n    }\n    return currIndex >= index;\n  }).forEach(([key, value]) => {\n    const currIndex = getIndexFromKeyAfterPath(key, pathString);\n    const newKey = key.replace(`${pathString}.${currIndex}`, `${pathString}.${currIndex + change}`);\n    cloned[newKey] = value;\n    changedKeys.add(newKey);\n    if (!changedKeys.has(key)) {\n      delete cloned[key];\n    }\n  });\n  return cloned;\n}\nexport { changeErrorIndices };","map":{"version":3,"names":["getIndexFromKeyAfterPath","key","path","split","substring","length","parseInt","changeErrorIndices","index","errors","change","pathString","String","clearedErrors","clearListState","cloned","changedKeys","Set","Object","entries","filter","startsWith","currIndex","Number","isNaN","forEach","value","newKey","replace","add","has"],"sources":["/Users/jackson/loginsystem/client/node_modules/@mantine/form/src/lists/change-error-indices.ts"],"sourcesContent":["import { clearListState } from './clear-list-state';\n\n/**\n * Gets the part of the key after the path which can be an index\n */\nfunction getIndexFromKeyAfterPath(key: string, path: string): number {\n  const split = key.substring(path.length + 1).split('.')[0];\n  return parseInt(split, 10);\n}\n\n/**\n * Changes the indices of every error that is after the given `index` with the given `change` at the given `path`.\n * This requires that the errors are in the format of `path.index` and that the index is a number.\n */\nexport function changeErrorIndices<T extends Record<PropertyKey, any>>(\n  path: PropertyKey,\n  index: number | undefined,\n  errors: T,\n  change: 1 | -1\n): T {\n  if (index === undefined) {\n    return errors;\n  }\n  const pathString = `${String(path)}`;\n  let clearedErrors = errors;\n  // Remove all errors if the corresponding item was removed\n  if (change === -1) {\n    clearedErrors = clearListState(`${pathString}.${index}`, clearedErrors);\n  }\n\n  const cloned = { ...clearedErrors };\n  const changedKeys = new Set<string>();\n  Object.entries(clearedErrors)\n    .filter(([key]) => {\n      if (!key.startsWith(`${pathString}.`)) {\n        return false;\n      }\n      const currIndex = getIndexFromKeyAfterPath(key, pathString);\n      if (Number.isNaN(currIndex)) {\n        return false;\n      }\n      return currIndex >= index;\n    })\n    .forEach(([key, value]) => {\n      const currIndex = getIndexFromKeyAfterPath(key, pathString);\n\n      const newKey: keyof T = key.replace(\n        `${pathString}.${currIndex}`,\n        `${pathString}.${currIndex + change}`\n      );\n      cloned[newKey] = value;\n      changedKeys.add(newKey);\n      if (!changedKeys.has(key)) {\n        delete cloned[key];\n      }\n    });\n\n  return cloned;\n}\n"],"mappings":";;;AAKA,SAASA,yBAAyBC,GAAA,EAAaC,IAAsB;EAC7D,MAAAC,KAAA,GAAQF,GAAI,CAAAG,SAAA,CAAUF,IAAK,CAAAG,MAAA,GAAS,CAAC,CAAE,CAAAF,KAAA,CAAM,GAAG,EAAE,CAAC;EAClD,OAAAG,QAAA,CAASH,KAAA,EAAO,EAAE;AAC3B;AAMO,SAASI,kBACdA,CAAAL,IAAA,EACAM,KACA,EAAAC,MAAA,EACAC,MACG;EACH,IAAIF,KAAA,KAAU,KAAW;IAChB,OAAAC,MAAA;EAAA;EAET,MAAME,UAAa,MAAGC,MAAO,CAAAV,IAAI,CAAC;EAClC,IAAIW,aAAgB,GAAAJ,MAAA;EAEpB,IAAIC,MAAA,KAAW,CAAI;IACjBG,aAAA,GAAgBC,cAAA,CAAe,GAAGH,UAAU,IAAIH,KAAK,IAAIK,aAAa;EAAA;EAGlE,MAAAE,MAAA,GAAS;IAAE,GAAGF;EAAc;EAC5B,MAAAG,WAAA,sBAAkBC,GAAY;EACpCC,MAAA,CAAOC,OAAA,CAAQN,aAAa,EACzBO,MAAA,CAAO,CAAC,CAACnB,GAAG,CAAM;IACjB,IAAI,CAACA,GAAI,CAAAoB,UAAA,CAAW,GAAGV,UAAU,GAAG,CAAG;MAC9B;IAAA;IAEH,MAAAW,SAAA,GAAYtB,wBAAyB,CAAAC,GAAA,EAAKU,UAAU;IACtD,IAAAY,MAAA,CAAOC,KAAM,CAAAF,SAAS,CAAG;MACpB;IAAA;IAET,OAAOA,SAAa,IAAAd,KAAA;EACrB,EACA,CAAAiB,OAAA,CAAQ,CAAC,CAACxB,GAAA,EAAKyB,KAAK,CAAM;IACnB,MAAAJ,SAAA,GAAYtB,wBAAyB,CAAAC,GAAA,EAAKU,UAAU;IAE1D,MAAMgB,MAAA,GAAkB1B,GAAI,CAAA2B,OAAA,CAC1B,GAAGjB,UAAU,IAAIW,SAAS,IAC1B,GAAGX,UAAU,IAAIW,SAAA,GAAYZ,MAAM,EACrC;IACAK,MAAA,CAAOY,MAAM,CAAI,GAAAD,KAAA;IACjBV,WAAA,CAAYa,GAAA,CAAIF,MAAM;IACtB,IAAI,CAACX,WAAA,CAAYc,GAAI,CAAA7B,GAAG,CAAG;MACzB,OAAOc,MAAA,CAAOd,GAAG;IAAA;EACnB,CACD;EAEI,OAAAc,MAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}